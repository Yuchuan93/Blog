<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity实现PBR Shader（上）</title>
      <link href="/blog/2021/07/28/PBR-Shader/"/>
      <url>/blog/2021/07/28/PBR-Shader/</url>
      
        <content type="html"><![CDATA[<p>这一篇先实现PBR的直接光照部分，效果如下：</p><p><img src=".\final.png" alt="final"></p><p>上面一排是Unity自带的URP Lit，关闭了环境光和环境镜面反射，下面的是自己的Shader，效果基本一样，不过算法略有不同，在URP中的算法有一些优化，后面再说。</p><h3 id="反射率公式"><a href="#反射率公式" class="headerlink" title="反射率公式"></a>反射率公式</h3><p><img src=".\equation.svg" alt="equation"></p><p>PBR的材质就是基于这个公式的实现，有很多文章解释了这个公式：</p><p><a href="https://zhuanlan.zhihu.com/p/21489591">如何看懂这些”该死的”图形学公式 - 知乎 (zhihu.com)</a></p><p><a href="https://learnopengl-cn.github.io/07 PBR/01 Theory/">理论 - LearnOpenGL CN (learnopengl-cn.github.io)</a></p><p><a href="https://zhuanlan.zhihu.com/p/53086060">【基于物理的渲染（PBR）白皮书】（一） 开篇：PBR核心知识体系总结与概览 - 知乎 (zhihu.com)</a></p><p>上面的公式翻译过来是这样：</p><p><img src=".\反射率公式翻译.svg" alt="反射率公式翻译"></p><p>再概括一下就是</p><script type="math/tex; mode=display">输出颜色 = \int_\Omega(k·漫反射颜色 + (1 - k)·镜面反射颜色)·光源颜色dw_i</script><p>直接上代码：</p><h3 id="镜面反射部分的实现"><a href="#镜面反射部分的实现" class="headerlink" title="镜面反射部分的实现"></a>镜面反射部分的实现</h3><h4 id="法线分布函数（DGF中的D）"><a href="#法线分布函数（DGF中的D）" class="headerlink" title="法线分布函数（DGF中的D）"></a>法线分布函数（DGF中的D）</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> D_GGX_TR(real3 N, real3 H, <span class="type">float</span> roughness)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> a      = roughness*roughness;</span><br><span class="line"><span class="type">float</span> a2     = a*a;</span><br><span class="line"><span class="type">float</span> NdotH  = <span class="built_in">max</span>(<span class="built_in">dot</span>(N, H), <span class="number">0.0</span>);</span><br><span class="line"><span class="type">float</span> NdotH2 = NdotH*NdotH;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> nom   = a2;</span><br><span class="line"><span class="type">float</span> denom = (NdotH2 * (a2 - <span class="number">1.0</span>) + <span class="number">1.0</span>);</span><br><span class="line">denom = PI * denom * denom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nom / denom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的参数包括N法线，H就是Blinn-Phong中的半角向量，roughness粗糙度。</p><h4 id="几何遮蔽（DGF中的G）"><a href="#几何遮蔽（DGF中的G）" class="headerlink" title="几何遮蔽（DGF中的G）"></a>几何遮蔽（DGF中的G）</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> GeometrySchlickGGX(<span class="type">float</span> NdotV, <span class="type">float</span> roughness)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> r = (roughness + <span class="number">1.0</span>);</span><br><span class="line"><span class="type">float</span> k = (r*r) / <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> nom   = NdotV;</span><br><span class="line"><span class="type">float</span> denom = NdotV * (<span class="number">1.0</span> - k) + k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nom / denom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> GeometrySmith(real3 N, real3 V, real3 L, <span class="type">float</span> roughness)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> NdotV = <span class="built_in">max</span>(<span class="built_in">dot</span>(N, V), <span class="number">0.0</span>);</span><br><span class="line"><span class="type">float</span> NdotL = <span class="built_in">max</span>(<span class="built_in">dot</span>(N, L), <span class="number">0.0</span>);</span><br><span class="line"><span class="type">float</span> ggx1 = GeometrySchlickGGX(NdotV, roughness);</span><br><span class="line"><span class="type">float</span> ggx2 = GeometrySchlickGGX(NdotL, roughness);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ggx1 * ggx2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里同时考虑了光线与法线的遮蔽和法线与视线的遮蔽。</p><h4 id="菲尼尔（DGF中F）"><a href="#菲尼尔（DGF中F）" class="headerlink" title="菲尼尔（DGF中F）"></a>菲尼尔（DGF中F）</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">real3 fresnelSchlick(<span class="type">float</span> cosTheta, real3 F0)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> F0 + (<span class="number">1.0</span> - F0) * <span class="built_in">pow</span>(<span class="number">1.0</span> - cosTheta, <span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的F0就是物质的基础反射率，这里可以简单的理解为反射的颜色，对于电介质（非金属），使用0.04这样的反射率已经足够好了；对于金属物体，表面会吸收所有折射光线而没有漫反射，所以我们可以直接使用表面颜色纹理来作为它们的基础反射率。所以使用一个金属度参数对这两种情况进行插值。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">real3 F0 = real3(<span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>);</span><br><span class="line">F0 = lerp(F0, albedo, metal);</span><br></pre></td></tr></table></figure><p>菲涅尔方程返回的是一个物体表面光线被反射的百分比， 也就是我们反射方程中的参数ks。现在这个公式中镜面反射的关键计算就都有了，分母中的wi和wo分别表示光线入射方向和光线出射方向（出射方向代表观察方向）。</p><h3 id="漫反射部分的实现"><a href="#漫反射部分的实现" class="headerlink" title="漫反射部分的实现"></a>漫反射部分的实现</h3><p>公式中的kd通过1-ks得到，所以漫反射颜色为：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">real3 diffuse = kD * albedo / PI</span><br></pre></td></tr></table></figure><p>漫反射和镜面反射的公式有了，而且比例是遵循了质量守恒的，现在就差总的入射光，也就是辐射量了，就是公式最后的Li，unity中直接使用光照颜色就行：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> attenuation = <span class="number">1</span>;</span><br><span class="line">float3 radiance = lightColor * attenuation;</span><br></pre></td></tr></table></figure><p>因为这一篇只讲直接光照，所以衰减为1。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;RichOne/MyPBR&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _NormalMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _MetallicMap (&quot;Metallic Map&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _Metallic (&quot;Metaliic&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        _Roughness (&quot;Roughness&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;   &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot;=&quot;UniversalForward&quot; &#125;</span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 positionCS : SV_POSITION;</span><br><span class="line">                float3 normalWS : TEXCOORD1;</span><br><span class="line">                float3 tangentWS : TEXCOORD2;</span><br><span class="line">                float3 binormalWS : TEXCOORD3;</span><br><span class="line">                float3 pos_world : TEXCOORD4;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            TEXTURE2D(_MainTex); SAMPLER(sampler_MainTex);</span><br><span class="line">            TEXTURE2D(_NormalMap); SAMPLER(sampler_NormalMap);</span><br><span class="line">            TEXTURE2D(_MetallicMap); SAMPLER(sampler_MetallicMap);</span><br><span class="line"></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">float</span> _Roughness;</span><br><span class="line">            <span class="type">float</span> _Metallic;</span><br><span class="line">            float4 _Color;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> D_GGX_TR(real3 N, real3 H, <span class="type">float</span> roughness)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> a      = roughness*roughness;</span><br><span class="line">                <span class="type">float</span> a2     = a*a;</span><br><span class="line">                <span class="type">float</span> NdotH  = <span class="built_in">max</span>(<span class="built_in">dot</span>(N, H), <span class="number">0.0</span>);</span><br><span class="line">                <span class="type">float</span> NdotH2 = NdotH*NdotH;</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> nom   = a2;</span><br><span class="line">                <span class="type">float</span> denom = (NdotH2 * (a2 - <span class="number">1.0</span>) + <span class="number">1.0</span>);</span><br><span class="line">                denom = PI * denom * denom;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> nom / denom;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> GeometrySchlickGGX(<span class="type">float</span> NdotV, <span class="type">float</span> roughness)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> r = (roughness + <span class="number">1.0</span>);</span><br><span class="line">                <span class="type">float</span> k = (r*r) / <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> nom   = NdotV;</span><br><span class="line">                <span class="type">float</span> denom = NdotV * (<span class="number">1.0</span> - k) + k;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> nom / denom;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> GeometrySmith(real3 N, real3 V, real3 L, <span class="type">float</span> roughness)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> NdotV = <span class="built_in">max</span>(<span class="built_in">dot</span>(N, V), <span class="number">0.0</span>);</span><br><span class="line">                <span class="type">float</span> NdotL = <span class="built_in">max</span>(<span class="built_in">dot</span>(N, L), <span class="number">0.0</span>);</span><br><span class="line">                <span class="type">float</span> ggx1 = GeometrySchlickGGX(NdotV, roughness);</span><br><span class="line">                <span class="type">float</span> ggx2 = GeometrySchlickGGX(NdotL, roughness);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ggx1 * ggx2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            real3 fresnelSchlick(<span class="type">float</span> cosTheta, real3 F0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> F0 + (<span class="number">1.0</span> - F0) * <span class="built_in">pow</span>(<span class="number">1.0</span> - cosTheta, <span class="number">5.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.positionCS = TransformObjectToHClip(v.vertex);</span><br><span class="line">                o.normalWS = TransformObjectToWorldNormal(v.normal);</span><br><span class="line">                o.tangentWS = TransformObjectToWorldDir(v.tangent) * v.tangent.w;</span><br><span class="line">                o.binormalWS = <span class="built_in">cross</span>(o.normalWS, o.tangentWS);</span><br><span class="line">                o.pos_world = TransformObjectToWorld(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            half4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half3 normalWS = <span class="built_in">normalize</span>(i.normalWS);</span><br><span class="line">                half3 tangentWS = <span class="built_in">normalize</span>(i.tangentWS);</span><br><span class="line">                half3 bitangentWS = <span class="built_in">normalize</span>(i.binormalWS);</span><br><span class="line">                real3x3 TBN = real3x3(tangentWS, bitangentWS, normalWS);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                half4 col = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">                half3 albedo = col.rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                real4 metal_var = SAMPLE_TEXTURE2D(_MetallicMap, sampler_MetallicMap, i.uv);</span><br><span class="line">                real metal = metal_var.r * _Metallic;</span><br><span class="line">                real smoothness = metal_var.a;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用SampleNormal方法</span></span><br><span class="line">                <span class="comment">// half3 normalTS = SampleNormal(i.uv, TEXTURE2D_ARGS(_NormalMap, sampler_NormalMap), 1).xyz;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                half4 n = SAMPLE_TEXTURE2D(_NormalMap, sampler_NormalMap,  i.uv);</span><br><span class="line">                half3 normalTS = UnpackNormal(n);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//手动Unpack，最好调用接口，会根据压缩类型进行解压</span></span><br><span class="line">                <span class="comment">// half3 normalTS;</span></span><br><span class="line">                <span class="comment">// normalTS.xy = n.ag * 2.0 - 1.0;</span></span><br><span class="line">                <span class="comment">// normalTS.z = max(0, sqrt(1.0 - saturate(dot(normalTS.xy, normalTS.xy))));</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// half3 normalDir = TransformTangentToWorld(normalTS, half3x3(tangentWS, bitangentWS, normalWS));</span></span><br><span class="line">                half3 normalDir = <span class="built_in">normalize</span>(mul(normalTS, TBN));</span><br><span class="line"></span><br><span class="line">                Light mainLight = GetMainLight();</span><br><span class="line">                real3 viewDir =  <span class="built_in">normalize</span>(GetWorldSpaceViewDir(i.pos_world));</span><br><span class="line"></span><br><span class="line">                float3 wi         = mainLight.direction;</span><br><span class="line">                float3 lightColor = mainLight.color;</span><br><span class="line">                <span class="type">float</span> attenuation = <span class="number">1</span>;</span><br><span class="line">                float3 radiance   = lightColor * attenuation;</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> cosTheta    = <span class="built_in">max</span>(<span class="built_in">dot</span>(normalDir, wi), <span class="number">0.0</span>);</span><br><span class="line">                real3 halfDir = <span class="built_in">normalize</span>(viewDir + wi);</span><br><span class="line"></span><br><span class="line">                real3 F0 = real3(<span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>);</span><br><span class="line">                F0      = lerp(F0,  albedo,  metal);</span><br><span class="line"></span><br><span class="line">                smoothness = smoothness * (<span class="number">1</span> - _Roughness);</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> NDF = D_GGX_TR(normalDir, halfDir, <span class="number">1</span> - smoothness);        </span><br><span class="line">                <span class="type">float</span> G   = GeometrySmith(normalDir, viewDir, wi, <span class="number">1</span> - smoothness);      </span><br><span class="line">                real3 F    = fresnelSchlick(<span class="built_in">max</span>(<span class="built_in">dot</span>(halfDir, viewDir), <span class="number">0.0</span>), F0);</span><br><span class="line"></span><br><span class="line">                real3 kS = F;</span><br><span class="line">                real3 kD = real3(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) - kS;</span><br><span class="line">                kD *= <span class="number">1.0</span> - metal;</span><br><span class="line"></span><br><span class="line">                real3 nominator    = NDF * G * F;</span><br><span class="line">                <span class="type">float</span> denominator = <span class="number">4.0</span> * <span class="built_in">max</span>(<span class="built_in">dot</span>(normalDir, viewDir), <span class="number">0.0</span>) * cosTheta + <span class="number">0.001</span>; </span><br><span class="line">                real3 specular     = nominator / denominator;</span><br><span class="line"></span><br><span class="line">                real3 diffuse = kD * albedo / PI;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 与unity的算法不同，光线偏暗，乘3后效果差不多</span></span><br><span class="line">                real3 finalColor = (diffuse + specular) * radiance * cosTheta * <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> real4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下一篇添加简介光照。。。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊算法</title>
      <link href="/blog/2021/06/09/Blur/"/>
      <url>/blog/2021/06/09/Blur/</url>
      
        <content type="html"><![CDATA[<h3 id="卷积核与卷积"><a href="#卷积核与卷积" class="headerlink" title="卷积核与卷积"></a>卷积核与卷积</h3><p>​    在图像处理中，卷积操作指的就是使用一个<strong>卷积核</strong> <strong>（kernel）</strong> 对一张图像中的每个像素进行一系列操作。卷积核通常是一个四方形网格结构（例如2×2、3×3的方形区域），该区域内每个方格都有一个权重值。当对图像中的某个像素进行卷积时，我们会把卷积核的中心放置于该像素上，如图12.4所示，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是该位置的新像素值。</p><p><img src=".\均值模糊.png" alt="均值模糊"></p><p>​    比如上图，使用一个3×3大小的卷积核对一张5×5大小的图像进行卷积操作，当计算图中红色方块对应的像素的卷积结果时，我们首先把卷积核的中心放置在该像素位置，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到新的像素值。</p><h3 id="均值模糊"><a href="#均值模糊" class="headerlink" title="均值模糊"></a>均值模糊</h3><p>​    还是如上面的图片所示，使用一个3x3的卷积核，当然也可以是2x2（可以使用4个角或者上下左右都行，看情况）、5x5，只要核内的每个元素的值的权重是相等的，就是均值模糊。</p><h3 id="降采样"><a href="#降采样" class="headerlink" title="降采样"></a>降采样</h3><p>​    在进行模糊算法的时候可以对原图像进行尺寸的压缩，不仅达到了模糊的效果，还提高了性能。</p><h3 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h3><p>​    高斯模糊同样利用了卷积计算，它使用的卷积核名为高斯核。高斯核是一个正方形大小的滤波核，其中每个元素的计算都是基于下面的高斯方程：</p><script type="math/tex; mode=display">G(x,y)=\frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}</script><p>​    其中，<em>σ</em> 是标准方差（一般取值为1），<em>x</em> 和<em>y</em> 分别对应了当前位置到卷积核中心的整数距离。要构建一个高斯核，我们只需要计算高斯核中各个位置对应的高斯值。为了保证滤波后的图像不会变暗，我们需要对高斯核中的权重进行归一化，即让每个权重除以所有权重的和，这样可以保证所有权重的和为1。因此，高斯函数中<em>e</em> 前面的系数实际不会对结果有任何影响。下方左图显示了一个标准方差为1的5×5大小的高斯核。</p><p>​    高斯方程很好地模拟了邻域每个像素对当前处理像素的影响程度——距离越近，影响越大。高斯核的维数越高，模糊程度越大。使用一个NxN的高斯核对图像进行卷积滤波，就需要N×N×W×H（W和H分别是图像的宽和高）次纹理采样。当N的大小不断增加时，采样次数会变得非常巨大。幸运的是，我们可以把这个二维高斯函数拆分成两个一维函数。也就是说，我们可以使用两个一维的高斯核（右图）先后对图像进行滤波，它们得到的结果和直接使用二维高斯核是一样的，但采样次数只需要2×N×W×H。我们可以进一步观察到，两个一维高斯核中包含了很多重复的权重。对于一个大小为5的一维高斯核，我们实际只需要记录3个权重值即可。</p><p><img src=".\高斯模糊卷积核.png" alt="高斯模糊卷积核"></p><p>这里的二维高斯函数拆分成一维函数用到了高斯函数的分离特性，即</p><script type="math/tex; mode=display">G(x,y)=G(x)*G(y)</script><p>推导过程：</p><script type="math/tex; mode=display">G(x,y)=\frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}=\frac{1}{2\pi\sigma^2}e^{-\frac{x^2}{2\sigma^2}-\frac{y^2}{2\sigma^2}}=\frac{1}{2\pi\sigma^2}e^{-\frac{x^2}{2\sigma^2}}*\frac{1}{2\pi\sigma^2}e^{-\frac{y^2}{2\sigma^2}}=G(x)*G(y)</script><p>​    使用横向的一维高斯核对图像进行滤波后，再使用纵向的高斯核进行一次滤波，得到最终图像就是高斯模糊算法的过程。并且我们能够通过调整滤波的应用次数来控制模糊程度，使用降采样来进一步提高性能。</p><h3 id="高斯模糊实现"><a href="#高斯模糊实现" class="headerlink" title="高斯模糊实现"></a>高斯模糊实现</h3><p>​    均值模糊核高斯模糊只是卷积核不同，所以这里就只记录一下高斯模糊的实现</p><p>Shader代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/GaussianBlur&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line"></span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        float2 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line">        struct v2f</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv[<span class="number">5</span>] : TEXCOORD0;</span><br><span class="line">            float4 vertex : SV_POSITION;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        v2f vertVertical(appdata_img v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            float2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv + float2(<span class="number">0.0</span>, -_MainTex_TexelSize.y) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv + float2(<span class="number">0.0</span>, -_MainTex_TexelSize.y * <span class="number">2</span>) * _BlurSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v2f vertHorizontal(appdata_img v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            float2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv + float2(-_MainTex_TexelSize.x, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2( _MainTex_TexelSize.x * <span class="number">2</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv + float2(-_MainTex_TexelSize.x * <span class="number">2</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fixed4 frag (v2f i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 只需要记录3个值</span></span><br><span class="line">            <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line"></span><br><span class="line">            fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> ite = <span class="number">1</span>; ite &lt; <span class="number">3</span>; ite++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[ite*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[ite];</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[ite*<span class="number">2</span>]).rgb * weight[ite];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> fixed4(sum, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 垂直方向上的模糊</span></span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vertVertical</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 水平方向上的模糊</span></span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vertHorizontal</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>c#脚本</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyBlur</span> : <span class="title">PostEffectsBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    Material mat;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    [<span class="meta">Range(0, 10)</span>]</span><br><span class="line">    <span class="built_in">int</span> iteration = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    [<span class="meta">Range(1, 32)</span>]</span><br><span class="line">    <span class="built_in">int</span> downSample = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    [<span class="meta">Range(0, 3)</span>]</span><br><span class="line">    <span class="built_in">float</span> blurSpread = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> width = Screen.width / downSample;</span><br><span class="line">        <span class="built_in">int</span> height = Screen.height / downSample;</span><br><span class="line"></span><br><span class="line">        RenderTexture buffer0 = RenderTexture.GetTemporary(width, height, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(source, buffer0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iteration; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mat.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">            RenderTexture buffer1 = RenderTexture.GetTemporary(width, height);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Render Vertical Pass</span></span><br><span class="line">            Graphics.Blit(buffer0, buffer1, mat, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">            buffer0 = buffer1;</span><br><span class="line"></span><br><span class="line">            buffer1 = RenderTexture.GetTemporary(width, height, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Render Horizontal Pass</span></span><br><span class="line">            Graphics.Blit(buffer0, buffer1, mat, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">            buffer0 = buffer1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.Blit(buffer0, destination);</span><br><span class="line">        RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终效果：</p><p><img src=".\原始图.png" alt="原始图"></p><p><img src=".\效果.png" alt="效果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在URP下渲染透明物体到深度纹理</title>
      <link href="/blog/2021/04/03/TransparentDepth/"/>
      <url>/blog/2021/04/03/TransparentDepth/</url>
      
        <content type="html"><![CDATA[<h2 id="深度纹理"><a href="#深度纹理" class="headerlink" title="深度纹理"></a>深度纹理</h2><p>在Unity的URP管线环境下，我们可以在管线设置中打开深度纹理直接供我们使用，相较于默认管线更为方便。这个深度纹理一般会用到后处理效果上，比如Unity内置的景深效果。</p><span id="more"></span><h2 id="URP的深度纹理实现"><a href="#URP的深度纹理实现" class="headerlink" title="URP的深度纹理实现"></a>URP的深度纹理实现</h2><p>Unity会根据情况，用两种不同的方式来实现深度纹理，一个是CopyDepth，一个是DepthPrepass。</p><h4 id="CopyDepth"><a href="#CopyDepth" class="headerlink" title="CopyDepth"></a>CopyDepth</h4><p>CopyDepth是在执行完非透明物体时会从深度缓冲中复制一份出来，可以很明显的判断出，这个深度是不包含透明物体的，因为渲染队列排在透明物体的前面，但是就算将队列放到透明物体后面，也不能保证透明物体在渲染的时候就一定会写入深度，通常情况下透明物体一般都不会写入深度。</p><h4 id="DepthPrepass"><a href="#DepthPrepass" class="headerlink" title="DepthPrepass"></a>DepthPrepass</h4><p>在某些情况下，比如开启了抗锯齿，Unity则会使用DepthPrepass的方式来渲染深度纹理，这个方式会提前将场景中物体的深度渲染一遍，使用的是物体本身Shader中PassTag为DepthOnly的pass。但是透明物体也还是被排除在外，我们通过源码看到，只有渲染队列为Opaque的物体会参与计算。</p><p><img src=".\DepthPrepass.png" alt=""></p><center>图1-1</center><p>下图是一个实例场景，三个cube，使用的shader是Lit，红色的是透明的，其他的是非透明的，红色和蓝色是距离摄像机位置相同，绿色的距离稍远，然后添加了景深后处理效果。</p><p><img src=".\1.png" alt=""></p><center>图1-2</center><p>可以看到，红色由于是透明物体，并没有正确的景深效果。我们打开FrameDebug，发现无论是CopyDepth还是DepthPrepass，都没有渲染透明物体。</p><p><img src=".\2.png" alt=""></p><center>图1-3</center><p><img src=".\3.png" alt=""></p><center>图1-4</center><h2 id="渲染透明物体的深度"><a href="#渲染透明物体的深度" class="headerlink" title="渲染透明物体的深度"></a>渲染透明物体的深度</h2><p>如果我们使用CopyDepth的方式来渲染透明深度就需要打开透明物体的深度写入，将深度写入到深度缓冲，然后将CopyDepth的队列放到透明物体后。但是这样的话会存在一个问题，就是不能保证透明物体的渲染正确。所以我这里选择用DepthOnly的方式来实现。</p><h4 id="修改DepthOnlyPass的队列设置"><a href="#修改DepthOnlyPass的队列设置" class="headerlink" title="修改DepthOnlyPass的队列设置"></a>修改DepthOnlyPass的队列设置</h4><p>根据图1-1可以看到，在构造DepthPrepass时传入了一个RenderQueueRange类型，进入这个类可以发现，其实有三个选项可以选，Opaque、Transparent和All。</p><p><img src=".\3-1.png" alt=""></p><center>图2-1</center><p>直接修改为all试一下。</p><p><img src=".\3-2.png" alt=""></p><center>图2-2</center><p><img src=".\3-3.png" alt=""></p><center>图2-3</center><p>深度写入成功了，景深效果也正常了。当然这样直接修改是不行的，所以接下来就是用一个更灵活、破坏性更小的方式来实现了。我们可以自己实现一个和DepthOnlyPass功能一样的RenderFeature来渲染一次深度，但是我觉得这样也不好，因为URP的实现里，无论我们是否打开深度纹理，我们使用的后处理需要用到深度纹理的话，Unity都会使用CopyDepth和DepthPrepass其中一个进行渲染，我们不能将这两个渲染操作全部关闭，也就相当于如果使用自定义的RenderFeature的话会多出一次渲染深度的操作。所以我使用了另一种方式，就是修改了DepthPrepass初始化的方式，通过设置来决定是否渲染透明物体的深度。</p><p>首先找到RenderObjects类，在RenderQueueType这个枚举中添加All字段，后面就直接用这个枚举了，当然也可以自己定义一个，不过放在这里可以在后面将RenderObjects这个RenderFeature一并扩展了。</p><p><img src=".\3-4.png" alt=""></p><center>图2-4</center><p>然后为DepthOnlyPass添加一个新的构造方法。</p><p><img src=".\3-5.png" alt=""></p><center>图2-5</center><p>然后找到UniversalRenderPipelineAsset类，再到General settings的部分添加这个设置，并添加访问函数，同时在编辑器类中也添加对应代码。</p><p><img src=".\3-6.png" alt=""></p><p><img src=".\3-7.png" alt=""></p><p><img src=".\3-9.png" alt=""></p><p>这时，就可以看到管线资源中的变化了。</p><p><img src=".\3-10.png" alt=""></p><p>接下来我们修改DepthOnlyPass初始化的地方，这样就算是基本准备好了。</p><p><img src=".\3-8.png" alt=""></p><p>当然这里只是实现了最基本的修改，前面也说到过DepthPrepass的开启是需要一定条件的，比如开启抗锯齿。这里其实可以添加一个判断，如果开启了透明物体的渲染，就开启DepthPrepass这个选项，我这里就直接开启抗锯齿看效果了。</p><p><img src=".\3-13.png" alt=""></p><p><img src=".\3-14.png" alt=""></p><p><img src=".\3-15.png" alt=""></p><p>由于深度纹理多数都用于后处理效果，除了后处理，一些需要用到深度信息的效果，比如描边、水面等也都会用到，所以透明物体的深度基本是必需的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> URP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个可以溶解的平面投影阴影</title>
      <link href="/blog/2020/07/05/ProjectorShadowDissolve/"/>
      <url>/blog/2020/07/05/ProjectorShadowDissolve/</url>
      
        <content type="html"><![CDATA[<p>​    最近项目项目上用到了平面投影阴影，原理是用一个单独的pass将模型顶点投影到一个平面上，这种方式有着不错的效率，但是也只能用在比较平的地面上，我们的项目刚好适用，而且还能跟随模型实现溶解的效果，一举两得。</p><h3 id="先来看看怎么实现阴影"><a href="#先来看看怎么实现阴影" class="headerlink" title="先来看看怎么实现阴影"></a>先来看看怎么实现阴影</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>​    实现投影阴影其实就是计算每一个顶点沿着光线方向与投影平面的交点坐标，然后将该点以黑色渲染出来，想象一下将这个模型沿着光线方向一巴掌拍扁在平面上，就是这个意思。我们可以用相似三角形原理来求它，如下图：</p><span id="more"></span><p>​    <img src=".\planerProjectorShadow.png" alt=""></p><p>​    现在问题转化为：已知B点和单位向量L（光照方向），求C点坐标。</p><p>​    由相似三角形定理，即对应边的比例相等，则有：</p><script type="math/tex; mode=display">-\frac{Ly}{By}=\frac{Lx}{Cx-Bx}</script><p>​    我们可以传入一个自定义的高度h，表示需要投影的平面高度：</p><script type="math/tex; mode=display">-\frac{Ly}{By-h}=\frac{Lx}{Cx-Bx}</script><p>​    那么就有：</p><script type="math/tex; mode=display">Cx=Bx-\frac{Lx(By-h)}{Ly}</script><script type="math/tex; mode=display">Cy=h</script><p>​    现在我们是在二维平面下进行的推导，放到三维也是一样的。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>​    上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ZWrite off</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">    </span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float4 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            uniform float _PlaneHeight;</span><br><span class="line">            uniform fixed3 _VirtualLightDir;</span><br><span class="line">            uniform fixed3 _ShadowColor;</span><br><span class="line">    </span><br><span class="line">            float3 ShadowProjectPos(float4 vertPos)</span><br><span class="line">            &#123;</span><br><span class="line">                float3 shadowPos;</span><br><span class="line">    </span><br><span class="line">                //得到顶点的世界空间坐标</span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, vertPos).xyz;</span><br><span class="line">    </span><br><span class="line">                //灯光方向</span><br><span class="line">                float3 lightDir = normalize(_VirtualLightDir.xyz);</span><br><span class="line">    </span><br><span class="line">                //阴影的世界空间坐标（低于地面的部分不做改变）</span><br><span class="line">                shadowPos.y = min(worldPos.y, _PlaneHeight);</span><br><span class="line">                shadowPos.xz = worldPos.xz - lightDir.xz * max(0, worldPos.y - _PlaneHeight) / lightDir.y; </span><br><span class="line">    </span><br><span class="line">                return shadowPos;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">    </span><br><span class="line">                //得到阴影的世界空间坐标</span><br><span class="line">                float3 shadowPos = ShadowProjectPos(v.vertex);</span><br><span class="line">    </span><br><span class="line">                //转换到裁切空间</span><br><span class="line">                o.vertex = UnityWorldToClipPos(shadowPos);</span><br><span class="line">    </span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                return fixed4(_ShadowColor, 1);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​    同时，我们需要从外部传入需要的参数，我这里直接在场景中创建一个空物体，挂上下面这个脚本，设置几个shader全局变量，也方便在场景中预览效果。</p><figure class="highlight c"><figcaption><span>VirtualLight.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode]</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualLight</span> :</span> MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> colorPropID = Shader.PropertyToID(<span class="string">&quot;_ShadowColor&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lightDir = Shader.PropertyToID(<span class="string">&quot;_VirtualLightDir&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heightPropID = Shader.PropertyToID(<span class="string">&quot;_PlaneHeight&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color shadowColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> height;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Shader.SetGlobalColor(colorPropID, shadowColor);</span><br><span class="line">        Shader.SetGlobalFloat(heightPropID, height);</span><br><span class="line">        Shader.SetGlobalVector(lightDir, transform.forward);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    到此，阴影效果就实现了，具体表现如下：</p><iframe src="final.gif" width="700" height="655" frameborder="0" loading="lazy" allowfullscreen></iframe><p>​    但是遇到了问题，当调节阴影的透明度时，效果就不正常了，如下图。这是因为阴影是平面的，但是我们计算的顶点却不是，这会造成很多顶点会重合的覆盖在平面上，造成颜色的叠加，解决办法就是用模板测试，丢弃那些会重合的像素。</p><p><img src=".\shadowerror.png" alt=""></p><p>​    修改后的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ZWrite off</span><br><span class="line">            Cull Back</span><br><span class="line"></span><br><span class="line">            Stencil</span><br><span class="line">            &#123;</span><br><span class="line">                // 参考值，表示每个像素用这个值来进行测试</span><br><span class="line">                Ref 0</span><br><span class="line">                // 比较方式，如果模板值等于参考值则通过测试，模板值初始为0</span><br><span class="line">                Comp equal</span><br><span class="line">                // 通过后模板值加1，这样后面的模板测试则不会通过了，保证一个像素只会填充一次</span><br><span class="line">                Pass incrWrap</span><br><span class="line">                // 模板测试和深度测试失败，保持原来的模板值</span><br><span class="line">                Fail keep</span><br><span class="line">                // 模板测试成功和深度测试失败，保持原来的模板值</span><br><span class="line">                ZFail keep</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            --------</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="接下来就是溶解效果了"><a href="#接下来就是溶解效果了" class="headerlink" title="接下来就是溶解效果了"></a>接下来就是溶解效果了</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>​    溶解就是利用透明度测试来实现，我们可以用一张灰度图来进行采样，然后再调节一个阈值，当采样到的值低于这个阈值时则抛弃这个像素。需要知道的是，我们不仅要模型本身要溶解，阴影也要溶解，所以两个pass都要进行同样的操作，这样会增加一次采样的消耗，不过不碍事，本次用到的灰度图如下：</p><p><img src=".\DissolveMaskSampleImage.png" alt=""></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>​    增加了溶解的shader完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Shader &quot;Yuchuan/PlaneProjectorShadow&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _DissolveMap(&quot;DissolveMap&quot;, 2D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _DissolveThreshold(&quot;DissolveThreshold&quot;, Range(0,1)) = 0</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD 100</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ZWrite off</span><br><span class="line">            Cull Back</span><br><span class="line">    </span><br><span class="line">            Stencil</span><br><span class="line">            &#123;</span><br><span class="line">                // 参考值，表示每个像素用这个值来进行测试</span><br><span class="line">                Ref 0</span><br><span class="line">                // 比较方式，如果模板值等于参考值则通过测试，模板值初始为0</span><br><span class="line">                Comp equal</span><br><span class="line">                // 通过后模板值加1，这样后面的模板测试则不会通过了，保证一个像素只会填充一次</span><br><span class="line">                Pass incrWrap</span><br><span class="line">                // 模板测试和深度测试失败，保持原来的模板值</span><br><span class="line">                Fail keep</span><br><span class="line">                // 模板测试成功和深度测试失败，保持原来的模板值</span><br><span class="line">                ZFail keep</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">    </span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float4 color : COLOR;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            uniform float _PlaneHeight;</span><br><span class="line">            uniform fixed3 _VirtualLightDir;</span><br><span class="line">            uniform fixed4 _ShadowColor;</span><br><span class="line">            sampler2D  _DissolveMap;</span><br><span class="line">            float _DissolveThreshold;</span><br><span class="line">    </span><br><span class="line">            float3 ShadowProjectPos(float4 vertPos)</span><br><span class="line">            &#123;</span><br><span class="line">                float3 shadowPos;</span><br><span class="line">    </span><br><span class="line">                //得到顶点的世界空间坐标</span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, vertPos).xyz;</span><br><span class="line">    </span><br><span class="line">                //灯光方向</span><br><span class="line">                float3 lightDir = normalize(_VirtualLightDir.xyz);</span><br><span class="line">    </span><br><span class="line">                //阴影的世界空间坐标（低于地面的部分不做改变）</span><br><span class="line">                shadowPos.y = min(worldPos.y, _PlaneHeight);</span><br><span class="line">                shadowPos.xz = worldPos.xz - lightDir.xz * max(0, worldPos.y - _PlaneHeight) / lightDir.y; </span><br><span class="line">    </span><br><span class="line">                return shadowPos;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">    </span><br><span class="line">                //得到阴影的世界空间坐标</span><br><span class="line">                float3 shadowPos = ShadowProjectPos(v.vertex);</span><br><span class="line">    </span><br><span class="line">                //转换到裁切空间</span><br><span class="line">                o.vertex = UnityWorldToClipPos(shadowPos);</span><br><span class="line">    </span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 mask = tex2D(_DissolveMap, i.uv);</span><br><span class="line">                if (mask.r &lt; _DissolveThreshold)</span><br><span class="line">                discard;</span><br><span class="line">                return _ShadowColor;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">    </span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">    </span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 worldNormal : TEXCOORD1;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D  _DissolveMap;</span><br><span class="line">            float _DissolveThreshold;</span><br><span class="line">    </span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                fixed4 mask = tex2D(_DissolveMap, i.uv);</span><br><span class="line">                if (mask.r &lt; _DissolveThreshold)</span><br><span class="line">                discard;</span><br><span class="line">    </span><br><span class="line">                return col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终成品：</p><iframe src="dissolve.gif" width="600" height="730" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始吧</title>
      <link href="/blog/2020/06/12/MyFirstBlog/"/>
      <url>/blog/2020/06/12/MyFirstBlog/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要建博客"><a href="#为什么要建博客" class="headerlink" title="为什么要建博客"></a>为什么要建博客</h2><p>​    花了几天时间，终于有了一个属于自己的博客，虽然我是一个工作几年的程序员，但搭建这个博客也还是耗费了些许精力，真是惭愧。我为什么想要弄一个自己的博客呢？其实这个想法很早就有了，但是一直因为各种原因（我不会说是因为拖延症）一直没有着手。直到最近，我突然发现工作了几年下来，总是感觉缺了点什么，没有自己能看得见的积累，自身的成长也很慢，我虽然一直对未来没有很迷茫，但目前多少有点不知所措，所以这个博客也算是很有必要了。</p><span id="more"></span><h2 id="这个博客要写些什么"><a href="#这个博客要写些什么" class="headerlink" title="这个博客要写些什么"></a>这个博客要写些什么</h2><p>​    首先会写的肯定是我的主业相关，也就是Unity游戏开发的相关内容，这可能会包括引擎相关技术、功能实现、渲染等；然后就是在工作中遇到的技术问题，这个博客一大用处就是在你解决问题后能将它记录下来，在记录的过程中也便于自己加深理解；除了这些技术相关的博文，我肯定还会有其他想要记录的东西，只是现在我还没有纳入或者说还没有发现。</p><h2 id="我期望这个博客能带来什么"><a href="#我期望这个博客能带来什么" class="headerlink" title="我期望这个博客能带来什么"></a>我期望这个博客能带来什么</h2><h3 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h3><p>​    希望我能通过这个博客改变我现有的一些工作方式，慢慢学习去记录，通过记录来提高对陌生知识的吸收效率，让自己的成长更快。</p><h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>​    把遇到的问题或者一些自己感觉到很酷的东西分享出来，不再自己一个人埋头苦干，如果有人能看到，然后能跟你交流，这也是一种快乐吧！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
